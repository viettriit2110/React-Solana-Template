{"ast":null,"code":"import EventEmitter from 'eventemitter3';\nimport { WalletNotConnectedError } from './errors.js';\nexport { EventEmitter };\n/**\n * A wallet's readiness describes a series of states that the wallet can be in,\n * depending on what kind of wallet it is. An installable wallet (eg. a browser\n * extension like Phantom) might be `Installed` if we've found the Phantom API\n * in the global scope, or `NotDetected` otherwise. A loadable, zero-install\n * runtime (eg. Torus Wallet) might simply signal that it's `Loadable`. Use this\n * metadata to personalize the wallet list for each user (eg. to show their\n * installed wallets first).\n */\nexport var WalletReadyState;\n(function (WalletReadyState) {\n  /**\n   * User-installable wallets can typically be detected by scanning for an API\n   * that they've injected into the global context. If such an API is present,\n   * we consider the wallet to have been installed.\n   */\n  WalletReadyState[\"Installed\"] = \"Installed\";\n  WalletReadyState[\"NotDetected\"] = \"NotDetected\";\n  /**\n   * Loadable wallets are always available to you. Since you can load them at\n   * any time, it's meaningless to say that they have been detected.\n   */\n  WalletReadyState[\"Loadable\"] = \"Loadable\";\n  /**\n   * If a wallet is not supported on a given platform (eg. server-rendering, or\n   * mobile) then it will stay in the `Unsupported` state.\n   */\n  WalletReadyState[\"Unsupported\"] = \"Unsupported\";\n})(WalletReadyState || (WalletReadyState = {}));\nexport class BaseWalletAdapter extends EventEmitter {\n  get connected() {\n    return !!this.publicKey;\n  }\n  async prepareTransaction(transaction, connection) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const publicKey = this.publicKey;\n    if (!publicKey) throw new WalletNotConnectedError();\n    transaction.feePayer = transaction.feePayer || publicKey;\n    transaction.recentBlockhash = transaction.recentBlockhash || (await connection.getLatestBlockhash({\n      commitment: options.preflightCommitment,\n      minContextSlot: options.minContextSlot\n    })).blockhash;\n    return transaction;\n  }\n}\nexport function scopePollingDetectionStrategy(detect) {\n  // Early return when server-side rendering\n  if (typeof window === 'undefined' || typeof document === 'undefined') return;\n  const disposers = [];\n  function detectAndDispose() {\n    const detected = detect();\n    if (detected) {\n      for (const dispose of disposers) {\n        dispose();\n      }\n    }\n  }\n  // Strategy #1: Try detecting every second.\n  const interval =\n  // TODO: #334 Replace with idle callback strategy.\n  setInterval(detectAndDispose, 1000);\n  disposers.push(() => clearInterval(interval));\n  // Strategy #2: Detect as soon as the DOM becomes 'ready'/'interactive'.\n  if (\n  // Implies that `DOMContentLoaded` has not yet fired.\n  document.readyState === 'loading') {\n    document.addEventListener('DOMContentLoaded', detectAndDispose, {\n      once: true\n    });\n    disposers.push(() => document.removeEventListener('DOMContentLoaded', detectAndDispose));\n  }\n  // Strategy #3: Detect after the `window` has fully loaded.\n  if (\n  // If the `complete` state has been reached, we're too late.\n  document.readyState !== 'complete') {\n    window.addEventListener('load', detectAndDispose, {\n      once: true\n    });\n    disposers.push(() => window.removeEventListener('load', detectAndDispose));\n  }\n  // Strategy #4: Detect synchronously, now.\n  detectAndDispose();\n}","map":{"version":3,"mappings":"AACA,OAAOA,YAAY,MAAM,eAAe;AAExC,SAASC,uBAAuB,QAAQ,aAAa;AAGrD,SAASD,YAAY;AAuCrB;;;;;;;;;AASA,WAAYE,gBAkBX;AAlBD,WAAYA,gBAAgB;EACxB;;;;;EAKAA,2CAAuB;EACvBA,+CAA2B;EAC3B;;;;EAIAA,yCAAqB;EACrB;;;;EAIAA,+CAA2B;AAC/B,CAAC,EAlBWA,gBAAgB,KAAhBA,gBAAgB;AAoB5B,OAAM,MAAgBC,iBAClB,SAAQH,YAAiC;EAWzC,IAAII,SAAS;IACT,OAAO,CAAC,CAAC,IAAI,CAACC,SAAS;EAC3B;EAWU,MAAMC,kBAAkB,CAC9BC,WAAwB,EACxBC,UAAsB,EACG;IAAA,IAAzBC,8EAAuB,EAAE;IAEzB,MAAMJ,SAAS,GAAG,IAAI,CAACA,SAAS;IAChC,IAAI,CAACA,SAAS,EAAE,MAAM,IAAIJ,uBAAuB,EAAE;IAEnDM,WAAW,CAACG,QAAQ,GAAGH,WAAW,CAACG,QAAQ,IAAIL,SAAS;IACxDE,WAAW,CAACI,eAAe,GACvBJ,WAAW,CAACI,eAAe,IAC3B,CACI,MAAMH,UAAU,CAACI,kBAAkB,CAAC;MAChCC,UAAU,EAAEJ,OAAO,CAACK,mBAAmB;MACvCC,cAAc,EAAEN,OAAO,CAACM;KAC3B,CAAC,EACJC,SAAS;IAEf,OAAOT,WAAW;EACtB;;AAGJ,OAAM,SAAUU,6BAA6B,CAACC,MAAqB;EAC/D;EACA,IAAI,OAAOC,MAAM,KAAK,WAAW,IAAI,OAAOC,QAAQ,KAAK,WAAW,EAAE;EAEtE,MAAMC,SAAS,GAAmB,EAAE;EAEpC,SAASC,gBAAgB;IACrB,MAAMC,QAAQ,GAAGL,MAAM,EAAE;IACzB,IAAIK,QAAQ,EAAE;MACV,KAAK,MAAMC,OAAO,IAAIH,SAAS,EAAE;QAC7BG,OAAO,EAAE;;;EAGrB;EAEA;EACA,MAAMC,QAAQ;EACV;EACAC,WAAW,CAACJ,gBAAgB,EAAE,IAAI,CAAC;EACvCD,SAAS,CAACM,IAAI,CAAC,MAAMC,aAAa,CAACH,QAAQ,CAAC,CAAC;EAE7C;EACA;EACI;EACAL,QAAQ,CAACS,UAAU,KAAK,SAAS,EACnC;IACET,QAAQ,CAACU,gBAAgB,CAAC,kBAAkB,EAAER,gBAAgB,EAAE;MAAES,IAAI,EAAE;IAAI,CAAE,CAAC;IAC/EV,SAAS,CAACM,IAAI,CAAC,MAAMP,QAAQ,CAACY,mBAAmB,CAAC,kBAAkB,EAAEV,gBAAgB,CAAC,CAAC;;EAG5F;EACA;EACI;EACAF,QAAQ,CAACS,UAAU,KAAK,UAAU,EACpC;IACEV,MAAM,CAACW,gBAAgB,CAAC,MAAM,EAAER,gBAAgB,EAAE;MAAES,IAAI,EAAE;IAAI,CAAE,CAAC;IACjEV,SAAS,CAACM,IAAI,CAAC,MAAMR,MAAM,CAACa,mBAAmB,CAAC,MAAM,EAAEV,gBAAgB,CAAC,CAAC;;EAG9E;EACAA,gBAAgB,EAAE;AACtB","names":["EventEmitter","WalletNotConnectedError","WalletReadyState","BaseWalletAdapter","connected","publicKey","prepareTransaction","transaction","connection","options","feePayer","recentBlockhash","getLatestBlockhash","commitment","preflightCommitment","minContextSlot","blockhash","scopePollingDetectionStrategy","detect","window","document","disposers","detectAndDispose","detected","dispose","interval","setInterval","push","clearInterval","readyState","addEventListener","once","removeEventListener"],"sourceRoot":"","sources":["../../src/adapter.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module","externalDependencies":[]}